{
  "hash": "8d28ccabfd881054f3e9987696c28e15",
  "result": {
    "markdown": "---\ntitle: \"Tagliare una linea con un punto\"\ndate: \"2022 04 18\"\nformat:\n    html:\n        code-fold: true\nexecute:\n  enabled: true\n---\n\nQuesta volta l'argomento trattato non nasce da una attività simile fatta con QGIS come per gli altri [post](https://maxdragonheart.github.io/PyGIS-Blog/) precedenti ma dalla soluzione ad un problema in cui mi sono imbattuto e che mi ha portato via un po' di tempo con non pochi grattacapi!\n\nLa richiesta era semplice, all'apparenza, ma non avevo fatto i conti con i *[Floating Point](https://docs.python.org/3/tutorial/floatingpoint.html) problems*. In pratica, avendo una linea ed un punto lontano da essa dovevo trovare la distanza minima tra punto e lina e spezzare la linea sul punto di contatto tra la congiungente tra punto e linea.\n\n## Prima di iniziare\n\n\n### Librerie\nPer raggiungere l'obiettivo userò le librerie che seguono:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom matplotlib import pyplot as plt\nfrom shapely import wkt\nfrom shapely.ops import substring, nearest_points, snap, split\nfrom shapely.geometry import Point, LineString\n\nimport warnings\nwarnings.filterwarnings('ignore')\nwarnings.simplefilter('ignore')\n```\n:::\n\n\n### Fonti dati\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\npoint = wkt.loads('POINT (437845.7257845374 4529752.584581757)')\nline = wkt.loads('LINESTRING (438260.8093535866 4528121.6968436185, 442844.8639858717 4531930.850183684)')\n\nfig, ax = plt.subplots(figsize=(10, 10))\nax.set_xlabel('X coordinate', fontsize=15)\nax.set_ylabel('Y coordinate', fontsize=15)\n\nax.scatter(\n    *point.xy,\n    label='Point',\n    s=100,\n    facecolor='orange',\n    edgecolor='black'\n)\nplt.plot(*line.xy, label='Line', color='blue')\n\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](2022-04-18-tagliare-una-linea-con-un-punto_files/figure-html/cell-3-output-1.png){width=857 height=820}\n:::\n:::\n\n\n# Premessa\n\nHo capito delle difficoltà legate ai *floating point* dopo questa esperienza:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nminimum_distance = nearest_points(point, line)[1]\n```\n:::\n\n\nCon `nearest_points()` ottengo il punto sulla linea più prossimo al mio punto di riferimento, a questo punto è naturale tagliare la linea con questo punto:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nsplitted_line = split(line, minimum_distance)\n\nfor line in list(splitted_line):\n    print(line)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLINESTRING (438260.8093535866 4528121.6968436185, 442844.8639858717 4531930.850183684)\n```\n:::\n:::\n\n\nLa funzione `split()` restiuisce una *geometry collection* composta da due *LineString*. Almeno questo è quello che mi sarei aspettato leggendo anche la documentazione della libreria usata, ma purtroppo anzicchè ottenere due linee ne ho ottenuta una, la linea in ingresso.\nQuindi mi è sorto un dubbio: **ma il punto con cui ho provato a tagliare la linea è realmente sulla linea?**\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nsnap_point = snap(minimum_distance, line, 1e-8)\n\nassert minimum_distance.wkt == snap_point.wkt\nassert line.distance(minimum_distance) < 1e-8\n```\n:::\n\n\nGli `assert` non hanno dato esito negativo, quindi il punto è sulla linea. **E allora perchè non riesco a tagliarla??**\n\nFacendo un po' di ricerche ho capito che il problema è legato ai *floating point* e così mi sono dato da fare per trovare una soluzione senza però trascurare altre possibili strade nel dubbio che magari potesse esserci un'altra strada o più di una. Infatti chiedendo un po' in giro ho trovato altre due soluzioni oltre la mia.\n\n# 1. Soluzione mia\nUso `nearest_points()` per trovare il punto più prossimo alla linea, quindi prendo il *from_node* ed il *to_node* della mia linea e li uso per creare due linee:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfirst_linestring = LineString([Point(line.coords[0]), minimum_distance])\nlast_linestring = LineString([minimum_distance, Point(line.coords[1])])\nminimum_distance_line = LineString([point, minimum_distance])\n```\n:::\n\n\nIn questo modo ho tagliato la linea ed ho creato la linea congiungente il mio punto iniziale con la linea stessa.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(10, 10))\nax.set_xlabel('X coordinate', fontsize=15)\nax.set_ylabel('Y coordinate', fontsize=15)\n\nplt.plot(*first_linestring.xy, label='Line', color='blue')\nplt.plot(*last_linestring.xy, label='Splitted line', color='green')\nplt.plot(*minimum_distance_line.xy, label='Minimum distance line', color='grey')\nax.scatter(\n    *point.xy,\n    label='Point',\n    s=100,\n    facecolor='orange',\n    edgecolor='black'\n)\nax.scatter(\n    *minimum_distance.xy,\n    label='Point on linestring',\n    s=100,\n    facecolor='red',\n    edgecolor='black'\n)\n\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](2022-04-18-tagliare-una-linea-con-un-punto_files/figure-html/cell-8-output-1.png){width=857 height=820}\n:::\n:::\n\n\n# 2. Soluzione basata su `projection()`\nSoluzione suggerita da due utenti sui social. In pratica si proietta il punto sulla linea andando ad individuare il punto di proiezione sulla stessa con cui si costruiscono le linee risultanti dal taglio.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndistance = line.project(point, normalized=True)\ndistance\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n0.12131606906976151\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nline_length = line.length\n\nfirst_linestring2 = substring(\n    geom=line,\n    start_dist=line_length*0,\n    end_dist=line_length*distance\n)\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(10, 10))\nax.set_xlabel('X coordinate', fontsize=15)\nax.set_ylabel('Y coordinate', fontsize=15)\n\nax.scatter(\n    *point.xy,\n    label='Point',\n    s=100,\n    facecolor='orange',\n    edgecolor='black'\n)\nplt.plot(*line.xy, label='Line', color='blue')\nplt.plot(*first_linestring.xy, label='Splitted line', color='green')\n\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](2022-04-18-tagliare-una-linea-con-un-punto_files/figure-html/cell-11-output-1.png){width=857 height=820}\n:::\n:::\n\n\nL'altra linea ed il punto di taglio si estraggono facilmente con procedimenti simili a quelli precedenti.\n\n# 3. Soluzione basata su `snap()`\nSoluzione suggerita da [M.Laloux](https://github.com/mlaloux) [qui](https://gis.stackexchange.com/a/428987/72195). In realtà ce ne è anche un'altra basata su `buffer()` ma avevo già incontrato precedetemente problemi legati ai *floating point* con quella funzione per cui l'ho scartata. La funzione usata per questa soluzione aggancia il punto di taglio alla linea e quindi effettua il taglio.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nsplitted_lines = split(snap(line, minimum_distance, 0.0001), minimum_distance)\n\nfig, ax = plt.subplots(figsize=(10, 10))\nax.set_xlabel('X coordinate', fontsize=15)\nax.set_ylabel('Y coordinate', fontsize=15)\n\nnew_lines = [minimum_distance_line]\nfor line in splitted_lines:\n    plt.plot(*line.xy, label='Splitted line', color='blue')\n    new_lines.append(line)\nplt.plot(*minimum_distance_line.xy, label='Minimum distance line', color='grey')\nax.scatter(\n    *point.xy,\n    label='Point',\n    s=100,\n    facecolor='orange',\n    edgecolor='black'\n)\nax.scatter(\n    *minimum_distance.xy,\n    label='Point on linestring',\n    s=100,\n    facecolor='red',\n    edgecolor='black'\n)\n\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](2022-04-18-tagliare-una-linea-con-un-punto_files/figure-html/cell-12-output-1.png){width=857 height=820}\n:::\n:::\n\n\n# Conclusione\n\nPurtroppo i problemi legati ai floating points in [shapely](https://github.com/shapely/shapely/issues?q=is%3Aissue+is%3Aopen+floating+point) restano irrisolti da un po' di anni. Le soluzioni proproste si pongoo nel caso più semplice: una linea composta da soli due vertex e cioè il *from_node* ed il *to_node*. Per situazioni più complesse si potrebbe iterare il discorso andando a segmentare la linea per poi ricongiungere i segmenti che fanno parte delle linee risultati dal taglio.\n\n**PS**: i riquadri di warning che si vedono ogni tanto *fanno parte del gioco*, sono avvertimenti per prossime modifiche da fare al codice per poter essere utilizzabile con la prossima versione della libreria di turno.\n\nHai commenti, indicazioni o soluzioni alternative in Python? Scrivi nella sezione [Discussioni](https://github.com/MaxDragonheart/PyGIS-Blog/discussions).\n\n## Newsletter\n\nSe vuoi ricevere aggiornamenti sui prossimi articoli [iscriviti alla newsletter](https://massimilianomoraca.it/newsletter/)!\n\n## Telegram\n\nSegui il canale Telegram **[CaffèGIS -  I GIS a supporto dei processi evolutivi territoriali](https://t.me/caffegis)** per ricevere aggiornamenti su iniziative ed informazioni a tema GIS.\n\n## Offrimi una birra!\n\n**Se trovi interessanti i miei articoli [offrimi una birra](https://www.paypal.com/paypalme/MassimilianoMoraca)!**\n\nAlla prossima!\n\n",
    "supporting": [
      "2022-04-18-tagliare-una-linea-con-un-punto_files"
    ],
    "filters": [],
    "includes": {}
  }
}